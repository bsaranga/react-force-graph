<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Force-Directed Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #333;
        }
        #graph-container {
            width: 90vw;
            height: 70vh;
            max-width: 1000px;
            max-height: 700px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden; /* Ensures SVG doesn't overflow rounded corners */
        }
        svg {
            display: block; /* Removes bottom space under SVG */
            width: 100%;
            height: 100%;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px; /* Default stroke width for links */
            cursor: pointer;
            transition: stroke 0.2s ease-in-out, stroke-opacity 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
        }
        .link:hover {
            stroke-opacity: 1;
            stroke-width: 2.5px;
        }
        .node { /* Apply cursor to the group as it's now the draggable element */
            cursor: pointer;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            transition: r 0.2s ease-in-out, fill 0.2s ease-in-out;
        }
        .node circle:hover {
            r: 10px; /* Slightly larger on hover, consider adjusting if base radius changes */
        }
        .node text {
            font-size: 10px;
            fill: #333;
            pointer-events: none; /* Text doesn't interfere with node events */
            text-anchor: middle;
            dy: 4px; /* Vertical alignment */
        }
        .controls {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .controls input, .controls button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
        }
        .controls button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .info-box {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
            font-size: 12px;
            max-width: 250px; /* Increased width for link info */
        }
    </style>
</head>
<body>
    <h1>Interactive Force-Directed Graph</h1>
    <div id="graph-container"></div>
    <div class="controls">
        <input type="text" id="newNodeId" placeholder="New Node ID">
        <input type="text" id="connectToNodeId" placeholder="Connect to (optional)">
        <button id="addNodeButton">Add Node</button>
    </div>
    <div id="selectionInfo" class="info-box" style="display:none;">Selected: <span id="selectedElementInfo"></span></div>

    <script>
        class ForceGraph {
            constructor(containerSelector, initialNodes = [], initialLinks = [], options = {}) {
                this.containerSelector = containerSelector;
                this.nodes = JSON.parse(JSON.stringify(initialNodes)); // Deep copy
                this.links = JSON.parse(JSON.stringify(initialLinks)); // Deep copy

                // Default options
                this.options = {
                    nodeRadius: 8,
                    linkDistance: 60,
                    chargeStrength: -150,
                    nodeColor: '#69b3a2',
                    highlightColor: '#f06292', // For nodes
                    linkStrokeWidth: 1.5,
                    highlightLinkColor: '#f06292', // For links, same as node for consistency or choose another
                    highlightLinkStrokeWidth: 3,
                    ...options
                };

                // Event handlers
                this.onNodeClickCallback = null;
                this.onLinkClickCallback = null;
                this.onNodeDragCallback = null; 

                this.selectedNode = null;
                this.selectedLink = null;

                this._init();
            }

            _init() {
                const container = d3.select(this.containerSelector);
                if (container.empty()) {
                    console.error(`Container element "${this.containerSelector}" not found.`);
                    return;
                }
                container.html(''); 

                this.width = container.node().getBoundingClientRect().width;
                this.height = container.node().getBoundingClientRect().height;

                this.svg = container.append("svg")
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height])
                    .on("click", (event) => { // Click on SVG background to deselect
                        if (event.target === this.svg.node()) { // Check if the click was directly on the SVG
                           this._clearSelections();
                        }
                    });


                this.linkGroup = this.svg.append("g").attr("class", "links");
                this.nodeGroup = this.svg.append("g").attr("class", "nodes");

                this.simulation = d3.forceSimulation(this.nodes)
                    .force("link", d3.forceLink(this.links).id(d => d.id).distance(this.options.linkDistance))
                    .force("charge", d3.forceManyBody().strength(this.options.chargeStrength))
                    .force("center", d3.forceCenter(0, 0)) 
                    .on("tick", this._ticked.bind(this));

                this._updateGraphElements();
            }

            _clearSelections(options = { clearNode: true, clearLink: true }) {
                if (options.clearNode && this.selectedNode) {
                    d3.select(this.selectedNode.eventTarget).attr("fill", this.options.nodeColor);
                    this.selectedNode = null;
                }
                if (options.clearLink && this.selectedLink) {
                    d3.select(this.selectedLink.eventTarget)
                        .style("stroke", this.options.linkDefaultColor || "#999") // Use a default or the general link color
                        .attr("stroke-opacity", 0.6)
                        .attr("stroke-width", this.options.linkStrokeWidth);
                    this.selectedLink = null;
                }
                 if (this.onNodeClickCallback && options.clearNode) this.onNodeClickCallback(null, null); // Notify deselection
                 if (this.onLinkClickCallback && options.clearLink) this.onLinkClickCallback(null, null); // Notify deselection
            }


            _updateGraphElements() {
                // Links
                this.linkElements = this.linkGroup
                    .selectAll("line")
                    .data(this.links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
                    .join("line")
                    .attr("class", "link")
                    .style("stroke", this.options.linkDefaultColor || "#999") // Ensure consistent default color
                    .attr("stroke-width", this.options.linkStrokeWidth)
                    .on("click", (event, d) => {
                        event.stopPropagation(); // Prevent SVG background click from firing immediately
                        this._handleLinkClick(event, d);
                    });

                // Nodes
                this.nodeElements = this.nodeGroup
                    .selectAll("g.node")
                    .data(this.nodes, d => d.id)
                    .join(
                        enter => {
                            const g = enter.append("g")
                                .attr("class", "node")
                                .call(this._dragHandler()); 

                            g.append("circle")
                                .attr("r", this.options.nodeRadius)
                                .attr("fill", this.options.nodeColor)
                                .on("click", (event, d) => {
                                    event.stopPropagation(); // Prevent SVG background click
                                    this._handleNodeClick(event, d);
                                });

                            g.append("text")
                                .text(d => d.id)
                                .attr("x", 0) 
                                .attr("y", this.options.nodeRadius + 12); 

                            return g;
                        },
                        update => update,
                        exit => exit.remove()
                    );

                this.simulation.nodes(this.nodes);
                this.simulation.force("link").links(this.links);
            }

            _ticked() {
                this.linkElements
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                this.nodeElements
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            }

            _dragHandler() {
                const dragstarted = (event, d) => {
                    if (!event.active) this.simulation.alphaTarget(0.3).restart();
                    d.fx = d.x; 
                    d.fy = d.y; 
                    if (this.onNodeDragCallback) this.onNodeDragCallback({ type: 'start', nodeId: d.id, event });
                };

                const dragged = (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                    if (this.onNodeDragCallback) this.onNodeDragCallback({ type: 'drag', nodeId: d.id, event });
                };

                const dragended = (event, d) => {
                    if (!event.active) this.simulation.alphaTarget(0);
                    // Only nullify fx, fy if it wasn't a click that also selected it
                    // This logic might need refinement if complex interactions are needed
                    if (!this.selectedNode || this.selectedNode.data.id !== d.id) {
                         d.fx = null; 
                         d.fy = null;
                    }
                    if (this.onNodeDragCallback) this.onNodeDragCallback({ type: 'end', nodeId: d.id, event });
                };

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }

            _handleNodeClick(event, d) {
                this._clearSelections({ clearNode: false, clearLink: true }); // Clear selected link, but not current node yet

                if (this.selectedNode && this.selectedNode.data.id === d.id) {
                    // Clicking the same node again deselects it
                    this._clearSelections();
                } else {
                    // Select new node
                    if (this.selectedNode) { // Clear previously selected node if any
                         d3.select(this.selectedNode.eventTarget).attr("fill", this.options.nodeColor);
                    }
                    d3.select(event.currentTarget).attr("fill", this.options.highlightColor);
                    this.selectedNode = { data: d, eventTarget: event.currentTarget };
                }
                
                if (this.onNodeClickCallback) {
                    this.onNodeClickCallback(this.selectedNode ? this.selectedNode.data : null, event);
                }
            }

            _handleLinkClick(event, d) {
                this._clearSelections({ clearNode: true, clearLink: false }); // Clear selected node, but not current link yet

                if (this.selectedLink && this.selectedLink.data === d) { 
                    // Clicking the same link again deselects it
                    this._clearSelections();
                } else {
                    // Select new link
                    if (this.selectedLink) { // Clear previously selected link
                         d3.select(this.selectedLink.eventTarget)
                            .style("stroke", this.options.linkDefaultColor || "#999")
                            .attr("stroke-opacity", 0.6)
                            .attr("stroke-width", this.options.linkStrokeWidth);
                    }
                    d3.select(event.currentTarget)
                        .style("stroke", this.options.highlightLinkColor)
                        .attr("stroke-opacity", 1)
                        .attr("stroke-width", this.options.highlightLinkStrokeWidth);
                    this.selectedLink = { data: d, eventTarget: event.currentTarget };
                }

                if (this.onLinkClickCallback) {
                    this.onLinkClickCallback(this.selectedLink ? this.selectedLink.data : null, event);
                }
            }


            addNode(newNodeData, connectToNodeId = null) {
                if (!newNodeData || !newNodeData.id) {
                    console.error("New node data must include an 'id'.");
                    return;
                }
                if (this.nodes.find(n => n.id === newNodeData.id)) {
                    console.warn(`Node with id "${newNodeData.id}" already exists.`);
                    return;
                }

                let initialX = 0;
                let initialY = 0;
                if (connectToNodeId) {
                    const targetNode = this.nodes.find(n => n.id === connectToNodeId);
                    if (targetNode) {
                        initialX = targetNode.x + (Math.random() - 0.5) * 20;
                        initialY = targetNode.y + (Math.random() - 0.5) * 20;
                    }
                } else { 
                    initialX = (Math.random() - 0.5) * (this.width / 4);
                    initialY = (Math.random() - 0.5) * (this.height / 4);
                }

                const completeNewNode = { ...newNodeData, x: initialX, y: initialY, fx: initialX, fy: initialY }; 
                this.nodes.push(completeNewNode);

                if (connectToNodeId) {
                    const targetNodeExists = this.nodes.find(n => n.id === connectToNodeId);
                    if (targetNodeExists) {
                        this.links.push({ source: newNodeData.id, target: connectToNodeId });
                    } else {
                        console.warn(`Cannot connect to non-existent node "${connectToNodeId}".`);
                    }
                }

                this._updateGraphElements();
                this.simulation.alpha(0.3).restart();

                setTimeout(() => {
                    const node = this.nodes.find(n => n.id === newNodeData.id);
                    if (node) {
                        node.fx = null;
                        node.fy = null;
                    }
                    if (this.simulation.alpha() < this.simulation.alphaMin()) { 
                        this.simulation.alpha(0.1).restart(); 
                     }
                }, 100);
            }

            removeNode(nodeId) {
                const nodeIndex = this.nodes.findIndex(n => n.id === nodeId);
                if (nodeIndex === -1) {
                    console.warn(`Node with id "${nodeId}" not found for removal.`);
                    return;
                }
                 // If the node being removed is selected, clear selection
                if (this.selectedNode && this.selectedNode.data.id === nodeId) {
                    this._clearSelections({ clearNode: true, clearLink: false }); // Only clear node part
                }

                this.nodes.splice(nodeIndex, 1);
                
                // Also remove links connected to this node and clear link selection if affected
                const oldLinkCount = this.links.length;
                this.links = this.links.filter(l => {
                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                    const isAffected = sourceId === nodeId || targetId === nodeId;
                    if (isAffected && this.selectedLink && this.selectedLink.data === l) {
                        this._clearSelections({ clearNode: false, clearLink: true }); // Only clear link part
                    }
                    return !isAffected;
                });


                this._updateGraphElements();
                this.simulation.alpha(0.1).restart();
            }

            onNodeClick(callback) {
                this.onNodeClickCallback = callback;
            }
            
            onLinkClick(callback) { // New public method
                this.onLinkClickCallback = callback;
            }

            onNodeDrag(callback) {
                this.onNodeDragCallback = callback;
            }

            updateData(newNodes, newLinks) {
                this._clearSelections();
                this.nodes = JSON.parse(JSON.stringify(newNodes));
                this.links = JSON.parse(JSON.stringify(newLinks));
                this._updateGraphElements();
                this.simulation.alpha(1).restart();
            }

            resize() {
                const container = d3.select(this.containerSelector);
                if (container.empty()) return;

                this.width = container.node().getBoundingClientRect().width;
                this.height = container.node().getBoundingClientRect().height;

                this.svg
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);

                this.simulation.force("center", d3.forceCenter(0,0));
                this.simulation.alpha(0.3).restart();
            }
        }

        // --- Example Usage ---
        document.addEventListener('DOMContentLoaded', () => {
            const initialNodes = [
                { id: "A" }, { id: "B" }, { id: "C" },
                { id: "D" }, { id: "E" }
            ];
            const initialLinks = [
                { source: "A", target: "B", value: 1 }, { source: "A", target: "C", value: 1 },
                { source: "B", target: "D", value: 1 }, { source: "C", target: "E", value: 1 },
                { source: "D", target: "E", value: 1 }
            ];

            const graph = new ForceGraph('#graph-container', initialNodes, initialLinks, {
                nodeRadius: 10,
                linkDistance: 100,
                chargeStrength: -250,
                highlightColor: '#ff4081', 
                highlightLinkColor: '#2196f3', // Different color for selected links
                highlightLinkStrokeWidth: 4,
                linkStrokeWidth: 2
            });

            const selectionInfoDiv = document.getElementById('selectionInfo');
            const selectedElementInfoSpan = document.getElementById('selectedElementInfo');

            graph.onNodeClick((nodeData, event) => {
                if (nodeData) {
                    console.log("Node clicked:", nodeData);
                    selectedElementInfoSpan.textContent = `Node: ${nodeData.id}`;
                    selectionInfoDiv.style.display = 'block';
                } else {
                    console.log("Node deselected");
                    selectionInfoDiv.style.display = 'none';
                }
            });

            graph.onLinkClick((linkData, event) => {
                if (linkData) {
                    const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
                    const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
                    console.log("Link clicked:", linkData);
                    selectedElementInfoSpan.textContent = `Link: ${sourceId} - ${targetId}`;
                    selectionInfoDiv.style.display = 'block';
                } else {
                    console.log("Link deselected");
                    selectionInfoDiv.style.display = 'none'; // Hide if nothing is selected
                }
            });

            graph.onNodeDrag(({type, nodeId, event}) => {
                // console.log(`Node drag event: ${type} on node ${nodeId}`);
            });

            const addNodeButton = document.getElementById('addNodeButton');
            const newNodeIdInput = document.getElementById('newNodeId');
            const connectToNodeIdInput = document.getElementById('connectToNodeId');

            addNodeButton.addEventListener('click', () => {
                const newNodeId = newNodeIdInput.value.trim();
                const connectTo = connectToNodeIdInput.value.trim() || null;

                if (newNodeId) {
                    graph.addNode({ id: newNodeId }, connectTo);
                    newNodeIdInput.value = '';
                    connectToNodeIdInput.value = '';
                } else {
                    const controlsDiv = document.querySelector('.controls');
                    let existingMsg = controlsDiv.querySelector('.error-message');
                    if (existingMsg) existingMsg.remove();

                    const errorMsg = document.createElement('div');
                    errorMsg.textContent = "Please enter a Node ID.";
                    errorMsg.style.color = 'red';
                    errorMsg.style.fontSize = '12px';
                    errorMsg.style.marginLeft = '10px';
                    errorMsg.classList.add('error-message');
                    addNodeButton.insertAdjacentElement('afterend', errorMsg);
                    setTimeout(() => errorMsg.remove(), 3000);
                }
            });

            window.addEventListener('resize', () => {
                graph.resize();
            });
        });
    </script>
</body>
</html>